#! /usr/bin/env python3
#  -*- coding: utf-8 -*-
#
# Support module generated by PAGE version 8.0
#  in conjunction with Tcl version 8.6
#    Jan 06, 2024 01:58:52 PM CET  platform: kwargsLinux
#    Jan 08, 2024 09:39:21 AM CET  platform: Linux
#    Jan 10, 2024 06:05:47 PM CET  platform: Linux
#    Jan 10, 2024 09:12:40 PM CET  platform: Linux
#    Jan 25, 2024 06:19:20 PM CET  platform: Linux
#    Jan 31, 2024 12:17:06 PM CET  platform: Linux
#    Jan 31, 2024 01:07:16 PM CET  platform: Linux

#   ========================================================
#
#     Module import section
#   ========================================================

import sys
import tkinter as tk
import tkinter.ttk as ttk
from tkinter.constants import *

import minnespel_smaabruk

_debug = True # False to eliminate debug printing from callback functions.

# Importing other required modules
try:
    from tkinter import font
    from tkinter import messagebox
    from tkinter.messagebox import _show
    import random
    import datetime
    import os
    import platform
    import PIL   
    from PIL import Image, ImageTk
    import numpy as np
    import imageio
    from screeninfo import get_monitors
    import datetime
    from time import sleep
except:
    # can't import essential modules
    sys.exit()

#   --------------------------------------------------------
#     Create share module and import it into the script
#   --------------------------------------------------------
module_name = "shared"   # empty_module
# Create the empty module file
with open(f"{module_name}.py", "w") as file:
    pass  # This creates an empty file
# Check if the file exists before importing
if os.path.isfile(f"{module_name}.py"):
    import importlib.util
    spec = importlib.util.spec_from_file_location(module_name, f"{module_name}.py")
    module = importlib.util.module_from_spec(spec)
    spec.loader.exec_module(module)
else:
    print(f"File '{module_name}.py' does not exist. Failed to import the module.")
sh=importlib   # sh is alias shared for short
#   -------------------------------------------------------B-

_debug = True # False to eliminate de_w1.Scrolledtext2.bug printing from callback functions.

# ToDo:
# Add a blank menu before the Edit menu to push it to the right
#    menubar.add_cascade(label="     ", menu=tk.Menu(menubar, tearoff=0))

#   ========================================================
#
#     app main section
#   ========================================================

def main(*args):
    '''Main entry point for the application.'''
    global root
    root = tk.Tk()
    root.protocol( 'WM_DELETE_WINDOW' , root.destroy)
    # Creates a toplevel widget.
    global _top1, _w1
    _top1 = root
    _w1 = minnespel_smaabruk.Toplevel1(_top1)
    minnespel_smaabruk_startup()
    root.mainloop()
        
def minnespel_smaabruk_startup():
    # a memory game
    # image lotto game using game board
    place_terminal()   # down to the left side on screene
    # give a a catchy name to this app
    _top1.title("playing memory game")
    sh.myFont0 = font.Font(family="Ubuntu", size=14)
    sh.myFont1 = font.Font(family="Ubuntu", size=16)
    sh.myFont2 = font.Font(family="Ubuntu", size=30)
    _w1.TLblExplanation.configure(text="")
    _w1.FrameLanguage.lift()
    menubar_fix()
    put_toplevel_on_center()
    init_var()
    give_sysem_info()
    set_icon()   # display an avatar on the taskbar_w1.Scrolledtext2.place(x=2000)
    display_splash()   # display an centered image on canvas for 5 seconds
    init_language_text()
    _w1.TLblExplanation.configure(foreground="#6B4322", text="ugla peikar på trong for spelarregistrering")
    display_owl_right()
    init_bindings()
    player_dict=sh.player_lst[sh.player]
    display_image(player_dict) # player 1 at init time
    _w1.TFrame2.place(x=2000)

def menubar_fix():
    '''give menubar new label, font, length and color'''
    # set space length
    _w1.menubar.entryconfigure("space0", label=" "*8)
    _w1.menubar.entryconfigure("space1", label=" "*75)
    _w1.menubar.entryconfigure("space2", label=" "*110)    
    # sert temp length of label
    _w1.menubar.entryconfigure("clock", label="_"*13, foreground="#8B8878")   # inkl. set font color
    _w1.menubar.entryconfigure("Title", label="_"*18, foreground="#8B8878")
    # set font
    _w1.menubar.entryconfigure("_____________", font=sh.myFont1)
    _w1.menubar.entryconfigure("__________________", font=sh.myFont1)

    
def init_path():
    # parent dir path
    sh.path_parent = os.getcwd()
    # photo dir path
    sh.path_photo = sh.path_parent+"/assets/lotto_graphics"

def init_canvas():
    sh.can1 = _w1.Canvas1
    sh.can2 = _w1.Canvas2
    sh.can3 = _w1.Canvas3
    sh.can4 = _w1.Canvas4
    sh.can5 = _w1.Canvas5
    sh.can6 = _w1.Canvas6
    sh.can7 = _w1.Canvas7
    sh.can8 = _w1.Canvas8
    sh.can9 = _w1.Canvas9
    sh.canvas_lst = [sh.can1, sh.can2, sh.can3, 
                     sh.can4, sh.can5, sh.can6, 
                     sh.can7, sh.can8, sh.can9]

def init_var():
    sh.language=1   # init language = us
    sh.next=1
    sh.cbi_value=1
    _w1.selectedButton.set(sh.language)
    set_logo_text()
    sh.big_im_dict = {}   # a dict to hold all raw images from dict 
    sh.big_im_random_dict = {}
    sh.im_dict = {}   # a dict to hold all thumbnail images from disc
    sh.rnd_im_dict={}   # a dict to hold all images in random orderinit_players_image_dict(sh.rnd_im_dict)
    # init a image dict for each player
    sh.player1_im={}
    sh.player2_im={}
    sh.player3_im={}
    sh.player4_im={}
    sh.player1_im_np={}
    sh.player2_im_np={}
    sh.player3_im_np={}
    sh.player4_im_np={}
    sh.player_lst=[sh.player1_im, sh.player2_im, sh.player3_im, sh.player4_im]
    sh.player1_solved={'0':0, '1':0, '2':0,
                       '3':0, '4':0, '5':0,
                       '6':0, '7':0, '8':0}
    sh.player2_solved={'0':0, '1':0, '2':0,
                       '3':0, '4':0, '5':0,
                       '6':0, '7':0, '8':0}
    sh.player3_solved={'0':0, '1':0, '2':0,
                       '3':0, '4':0, '5':0,
                       '6':0, '7':0, '8':0}
    sh.player4_solved={'0':0, '1':0, '2':0,
                       '3':0, '4':0, '5':0,
                       '6':0, '7':0, '8':0}
    sh.player_name={}
    sh.player=0
    sh.players_turn=sh.player
    sh.decoration = 53
    sh.break_length_card = 2000
    sh.direction=0
    sh.form_color_lst=['blue', 'yellow', 'red', 'green']
    random.shuffle(sh.form_color_lst)
    _w1.Label1.configure(background=sh.form_color_lst[0])
    _w1.Label2.configure(background=sh.form_color_lst[1])
    _w1.Label3.configure(background=sh.form_color_lst[2])
    _w1.Label4.configure(background=sh.form_color_lst[3])
    sh.style = ttk.Style()
    make_mystyle()
    ###sh.id_lst=['MyTButton1.TButton','MyTButton2.TButton','MyTButton3.TButton','MyTButton4.TButton']
    ## sh.button_lst=[_w1.TBtnPlayer1, _w1.TBtnPlayer2, _w1.TBtnPlayer3, _w1.TBtnPlayer4]
    sh.u_text={'1': "potetåker i blomst",
               '2': "Vedstabelen rasa saman. Den hadde krympa under tørking.\nDifor er stablar av favneved kun er ein meter høge.",
               '3': '"Skogbrann" stod å lese i lokalavisa. Born i nabolaget hadde leika ved\neit bål. Dette resulterte i at 35 mål skog vart øydelagd.',
               '4': "Felling av store tre med motorsag. Tre som veks seg store står i fare\nfor å ramle over ende i storm. Særleg ved hus kan dei gjere skade.",
               '5': "Mykje greiner å ryddja etter trefelling. Tjukke greiner blir til\nved, medan det andre blir sanka saman og brent på bål.",
               '6': "Bonden fører tilsyn med eigedommen sin. Beitevandring er ofte nytta.\nHer er det biltur til Vabakkjen ved Sørakjødno.",
               '7': "Storavatnet er omlag 6 km langt. Det er eit fiskerikt vassdrag og\ndet fylgjer fiskerettar med garden.",
               '8': "Her er det lasta opp ei trestamme som skal til sagbruk\nfor å bli til materialar.",
               '9': "Liarbønaustet er eit gamalt båthus bygd av stein.\nHer ved Storavatnet hadde dei fått løyve til å ha båten sin.",
              '10': "Avkjøyrsle mot skogen. Her vart det i gamal tid flytta buskap mot\nTislavollsetera, og henta ved og tømmer.",
              '11': "Menzi muck 3000EH er ein gravemaskin frå -70 talet. Den er hendig\ntil grøftevedlikehald, opplasting og løfting.",
              '12': "Når bonden har fôra dyra er det viktig å vera i sammen med dei for\nå følgja med. Har dyra det bra, er alle kome inn, eller er nokon sjuke.",
              '13': "Lamminga er den travlaste tida. Mange sauer må ha hjelp, men når\nlamma finn mat hjå mor går det oftast bra.",
              '14': "Tvillingar, er lykka for sau og bonde. Her er to trivelege lam.\nTru om dei har det bra?",
              '15': "Gamle løa er reparet monge gongar. Ho er vorte så dårleg at\ndet er tid for riving.",
              '16': "Potetopptak er innhausting av poteteavling. Her er potetene\nkomme i eigne luftige potetkassar, klar for lagring.",
              '17': "Oselvaren er lagra i naustet ved Storavatnet. Det er tre bord i\nein Oselvar. Dette er gamal båtbyggjar kunst, eldre en vikingtida.",
              '18': "Traktoren er nyttig til transport av greiner som skal\ntil bålplassen etter trefelling.",
              '19': "Traktor; Same Falcon 4wd 50 hk m/laster, kjøpt på Osterøy.",
              '20': "Gardsbil; Mitsubish L200 pickup, kjøpt hos Fylkesnes Bil as på Stord.",
              '21': "Gardsveiane er livsnerva, her vert menneska, dyr, fôr,\nog trevirke frakta. Det er viktig å vedlikehalda desse.",
              '22': '"Silopress", når graset er hausta inn til siloen, må denne bli lufttett.\nDette blir gjort med plast og lodd mot siloveggen.',
              '23': "Hagestell er trivseltiltak.\nHer vert det planta i blomar i eit bed ved våningshusert.",
              '24': "Sauehuset ligg på ein haug nær tunet. I bakgrunnen ser ein fjellbeitet.\nRundt er det vedskog, beite og slotteeng.",
              '25': "Ranveigstova frå ca.1770 vart flytta hit frå hovud tunet på garden då\nden vart delt mellom to brødre i 1850 og er ein del av huset.",
              '26': "Frittgåande høner har det godt her. Hanen har tidlegare\nlevd med ein vær, men er no lykkelig saman med nokre høner.",
              '27': "Vabakkjen er 18 mål fuldyrka jord. Her er ein god stad for\nhjortejakt. Til høgre ligg ein bekk som ein vada over i gamal tid.",
              '28': "Midttjødo ligg nordom Vahaugen. Bakkjen til høgre her er\nein del av Vabakkjen som vart dyrka på 1990 talet",
              '29': "Nausthaugen ligg nordom naustbakkjen der me\nfeirar st.Hans.",
              '30': "st.Hansbål er avsluttninga på feiringa kvart år,\nfor ca. 20 personer.",
              '31': "Ospetre i haustskrud. Dessverre vart klyngja kvesta av\nein storm. Seks trær velta den gongen.",
              '32': "Ei Hesja er når ein haustar gras som vert hengt opp til tørk\npå strengjer som her. Det blir godt høy om det vert tort.",
              '33': "Graset spirer og gror. Når det er modent kan det haustast til\nfôr for husdyr.",
              '34': "Driftsbygning med to siloar for 50 vinterfôra sauer.\nHer er strekkmetallgulv og siloheis med klype.",
              '35': "Utmarksbeite ved torvmyro.",
              '36': "Kalvabeite mot nordaust.",
              }    
    set_form_color(sh.player)
    ## set_button_color()
    init_canvas()
    init_path()

    # do not init this before player registration
    img_number = 36   # set number of images to load

    # make a list of all image names by List Comprehension
    sh.im_lst=[f'{x}.png' for x in range(1,img_number+1)]
    ## print(im_lst)   # ['1.png', '2.png', '3.png', '4.png', '5.png', '6.png', '7.png', '8.png', '9.png', '10.png', '11.png', '12.png', '13.png', '14.png', '15.png', '16.png', '17.png', '18.png', '19.png', '20.png', '21.png', '22.png', '23.png', '24.png', '25.png', '26.png', '27.png', '28.png', '29.png', '30.png', '31.png', '32.png', '33.png', '34.png', '35.png', '36.png']
    init_image_dict()
    sh.rnd_im_dict = dict_randomization(sh.im_dict)
    sh.round_num=0
    sh.new_round=True
    init_players_image_dict(sh.rnd_im_dict)
    global _question
    # set playbutton back
    fn="question_mark.png"
    photo_location = os.path.join(sh.path_photo,fn)
    sh.quest_name=photo_location
    quest = Image.open(photo_location)
    thumbnail_size=(200,200)
    quest.thumbnail(thumbnail_size)   # 600x600 -> 200x200
    _question = ImageTk.PhotoImage(quest)

def init_image_dict():
    # make a dicts with all images
    sh._img=[]
    sh.img_np=[]
    global _img
    for inx, im in enumerate(sh.im_lst):
        if inx < 36:
            # join path and filename to photo_location for a photo
            fn = im
            photo_location = os.path.join(sh.path_photo,fn)
            sh.img_np.append(photo_location)
            #loading the image 
            original = Image.open(photo_location)
            sh.big_im_dict[str(inx)]=(photo_location, ImageTk.PhotoImage(original))
            # create a thumbnail
            thumbnail_size=(200,200)
            original.thumbnail(thumbnail_size)   # 600x600 -> 200x200
            sh._img.append(inx+1)
            sh._img[inx] = ImageTk.PhotoImage(original)
            # save original thumbnail to dict
            _img=f'{sh._img[inx]}'
            if not _img in sh.im_dict:
                sh.im_dict[_img] = (photo_location, ImageTk.PhotoImage(original), inx)

def init_players_image_dict(rnd_im_dict):
    # split dict into four equal chunks
    cnt=1
    for key, values in rnd_im_dict.items():
        if cnt==1:
            sh.player1_im[key]=values
        elif cnt==2:
            sh.player2_im[key]=values
        elif cnt==3:
            sh.player3_im[key]=values
        elif cnt==4:
            sh.player4_im[key]=values
        cnt+=1
        if cnt==5:
            cnt=1
    cnt=1
    key1='1'
    key2='1'
    key3='1'
    key4='1'
    key5='1'
    key6='1'
    key7='1'
    key8='1'
    key9='1'
    for inx, values in enumerate(sh.random_img_np):
        if cnt==1:
            sh.player1_im_np[key1]=values
            temp=int(key1)
            temp+=1
            key1=str(temp)
        elif cnt==2:
            sh.player2_im_np[key2]=values
            temp=int(key2)
            temp+=1
            key2=str(temp)
            key2=str(key2)
        elif cnt==3:
            sh.player3_im_np[key3]=values
            temp=int(key3)
            temp+=1
            key3=str(temp)
            key3=str(key3)
        elif cnt==4:
            sh.player4_im_np[key4]=values
            temp=int(key4)
            temp+=1
            key4=str(temp)
            key4=str(key4)
        cnt+=1
        if cnt==5:
            cnt=1

def dict_randomization(d):
    ''' How To Iterate Over A Python Dictionary In Random Order? 
        To iterate over the dictionary items in random order get 
        the list of items in a tuple with .items() 
        then shuffle and iterate through this list using 
        the shuffle() and make a new dict with the result'''
    rnd_d={}
    items = list(d.items()) # List of tuples of (key,values)
    random.shuffle(items)
    make_random_np(items)   # list after shuffle
    for key, value in items:
        # print(key, ":", value)
        rnd_d[key]=value
    return rnd_d

def make_random_np(shuffled_list):
    # Enumerate to create a list of tuples (original_index, value)
    original_order = list(enumerate(shuffled_list))
    # Sort the list based on the values to get the original order
    original_order.sort(key=lambda x: x[1])
    # Extract the original indices from the sorted list
    order_of_shuffled_list = [index for index, _ in original_order]
    ## make a random np list of shuffled 'sh.img_np' by 'sh.rnd_im_dict'
    original_list = sh.img_np
    order_list = order_of_shuffled_list
    # Zip the two lists together
    zipped_lists = list(zip(order_list, original_list))
    # Sort based on the order_list
    zipped_lists.sort()
    # Extract the elements from the sorted list
    result_list = [element for _, element in zipped_lists]
    # populate sh.random_img_np with result_list 
    sh.random_img_np = result_list
    # likewise make sh.big_im_dict in random order
    zipped_lists = list(zip(order_list, sh.big_im_dict))
    zipped_lists.sort()
    sh.big_im_random_dict = [element for _, element in zipped_lists]

def init_language_text():
    if not sh.language:
        # set English language on widgetssh.current_time_1
        _w1.TLabel5.configure(text='''Player Registration''')
        _w1.TLabel1.configure(text='''player 1''')
        _w1.TLabel2.configure(text='''player 2''')
        _w1.TLabel3.configure(text='''player 3''')
        _w1.TLabel4.configure(text='''player 4''')
        _w1.TBtnNext.configure(text='''Next''')
        _w1.TBtnGoOn.configure(text='''Go On''')
        ##_w1.TBtnExit.configure(text='''Exit''')
    else:
        # set Norwegian language on widgets
        _w1.TLabel5.configure(text='''Registrer spelarane her:''')
        _w1.TLabel1.configure(text='''spelar 1''')
        _w1.TLabel2.configure(text='''spelar 2''')
        _w1.TLabel3.configure(text='''spelar 3''')
        _w1.TLabel4.configure(text='''spelar 4''')
        _w1.TBtnNext.configure(text='''Neste''')
        _w1.TBtnGoOn.configure(text='''Start''')
        ##_w1.TBtnExit.configure(text='''Avslutt''')

def init_bindings():
    # set binding to Go On button
    _w1.TBtnGoOn.bind('<Return>', on_TBtnGoOn)
    # set binding to entry/return key
    _w1.TEntry1.bind('<Return>', retur_entry1)
    _w1.TEntry2.bind('<Return>', retur_entry2)
    _w1.TEntry3.bind('<Return>', retur_entry3)
    _w1.TEntry4.bind('<Return>', retur_entry4)
    # Trace changes in the entry value
    _w1.player1var.trace_add("write", validate_input1)
    _w1.player2var.trace_add("write", validate_input2)
    _w1.player3var.trace_add("write", validate_input3)
    _w1.player4var.trace_add("write", validate_input4)
    # make canvases turnable
    sh.can1.bind('<Button-1>', lambda e: turn_card(e,1))
    sh.can2.bind('<Button-1>', lambda e: turn_card(e,2))
    sh.can3.bind('<Button-1>', lambda e: turn_card(e,3))
    sh.can4.bind('<Button-1>', lambda e: turn_card(e,4))
    sh.can5.bind('<Button-1>', lambda e: turn_card(e,5))
    sh.can6.bind('<Button-1>', lambda e: turn_card(e,6))
    sh.can7.bind('<Button-1>', lambda e: turn_card(e,7))
    sh.can8.bind('<Button-1>', lambda e: turn_card(e,8))
    sh.can9.bind('<Button-1>', lambda e: turn_card(e,9))

#   ========================================================
#
#     supporting routine section
#   ========================================================

def set_icon():   # place a icon (avatar)
    '''routine to place avatar icon on taskbar'''
    # by G.D. Walters
    p1 = tk.Image("photo", file='assets/graphic/avatar.png')
    root.tk.call('wm', 'iconphoto', root._w, p1)

def place_terminal():   # Terminal place on screen
    '''routine to clean up the display during debug runtime, else hide terminal window'''
    if _debug:
        # put the Terminal form to left edge (usfull when using Geany IDE)
        import pyautogui
        pyautogui.hotkey('win','left','down')
    else:
        # minimize the Terminal form
        import pyautogui
        pyautogui.hotkey('alt','f10')   # maximize Terminal form first
        pyautogui.moveTo(1840,17, duration=0.2)   # go to minimize button
        pyautogui.doubleClick()   # minimize

def put_toplevel_on_center():   # Toplevel place on screen
    '''routine which set appropriate argument value for using one or 
       more displays and calling the center_toplevel routine'''
    monitors = get_monitors()
    # the a ability to automate the selection
    if len(monitors) == 1:   # only one monitor
        screen = 1
    else:
        # print(f"There are {len(monitors)} monitors.")
        screen = 2
    # top.geometry("1360x737+32+55") -- from gui file
    wid=1360
    hei=737
    if 1 <= screen <= len(monitors):
        screen = monitors[screen - 1]
        window_width = wid
        window_height = hei
        x = screen.x + (screen.width - window_width) // 2
        y = screen.y + (screen.height - window_height) // 2
        _top1.geometry(f"{window_width}x{window_height}+{x}+{y}")

def give_sysem_info():   # put system info into Terminal
    '''routine which write information about this application in terminal'''
    # remember to update myFile !!!
    # get system info
    py_f_name =    os.path.basename(sys.argv[0])
    current_path = os.path.abspath(__file__)
    py_version =   platform.python_version()
    author =       'Halvard Tislavoll'
    licence =      'MIT'
    current_time = datetime.datetime.now()
    sh.current_time_1 = f'{current_time.hour:02}:{current_time.minute:02}:{current_time.second}'
    # read this file and get page version on line 4
    myFile="./minnespel_smaabruk_support.py"
    signal, all_text=read_text_file_lines(myFile)
    if signal:
        txt_lst=all_text.split('\n')
        sh.page_version=txt_lst[4][-4:]   # list out last of a function line, the "8.0G" from "... PAGE version 8.0G"
        # It is in line 4 but count from 0 it is 3
    else:
        print('Trouble, no _support file is found. Have you give the right name?')
    # print system info
    print()
    print(f'{current_time.year}-{current_time.month}-{current_time.day}')
    print(f'   GUI is constructed using page version {sh.page_version}')
    print(f'   Current path: {current_path}')
    print(f'   Python ver. : {py_version}')
    print(f'   File        : "{py_f_name}" is running')
    print(f'   Start time  : {sh.current_time_1}')
    print(f'   © Copyright : {author}, 2024')
    print(f'   Licence     : {licence}')
    print('-'*sh.decoration, '\n')

def read_text_file_lines(filename):
    '''function which read text from file and return the
     file content in a string'''
    try:
        with open(filename, 'r') as f:
            f_text = f.read()
            signal = True   # Done.
            return signal, f_text
    except IOError:
        signal = False   # Something went wrong !!
        return signal, ''

def fade_in():   #   gradually Toplevel entrance
    '''routine to make the toplevel fadeing into the display'''
    # The fade in might not work under Windows
    if platform.system() == 'Windows':
        _top1.overridedirect(True)
    else:
        _top1.wm_attributes('-type', 'splash')
    for a in range(0, 100):
        b = a * .02
        _top1.wm_attributes('-alpha', b)
        _top1.update()
        sleep(.01)
    
def a_break(t):   # the action in run time take a break
    '''routine which make the action in run time take a break'''
    var = tk.IntVar()
    root.after(t, var.set, 1)
    root.wait_variable(var)

def test_solved(num):   # is images equal than solved
    #print('test_solved:', sh.player, type(sh.player))
    if sh.player==0:
        if sh.player1_solved[str(num)]:
            return True
        else:
            return False
        # sh.player1_solved
    elif sh.player==1:
        if sh.player2_solved[str(num)]:
            return True
        else:
            return False    
    elif sh.player==2:
        if sh.player3_solved[str(num)]:
            return True
        else:
            return False
    elif sh.player==3:
        if sh.player4_solved[str(num)]:
            return True
        else:
            return False

def is_solved(which):
    # compare thumbnail img and random big img if equal than set flag
    # extract the image number from path
    current_tumbnail_image = eval(f'sh.player{sh.player+1}_im_np[str({which})]')
    sh.cti_value=str(current_tumbnail_image.split('/')[-1:])[2:-6]
    player_number=str(int(sh.player)+1)
    if sh.cti_value == sh.cbi_value:
        print("EQUAL IMAGES!!!")              # EQUAL IMAGES!!!
        print(f'Equal images = True,  {sh.cti_value} = {sh.cbi_value}')   # Equal images = True,  1 = 1
        solved_dict_name=eval(f'sh.player{player_number}_solved')
        the_key=str(which)
        # set player solved = 1
        solved_dict_name[the_key]=1
        # print(solved_dict_name)

        display_random()
    else:
        print(f'Equal images = False, {sh.cti_value} ≠ {sh.cbi_value}')
        slide(which)  # turn image back
        
        # change big image
        sh.player+=1
        if sh.player==5:
            sh.player=1

        set_form_color(sh.player)
        pl_btn=f'on_TBtnPlayer{player_number}()'
        eval(pl_btn)

        player_dict=sh.player_lst[sh.players_turn]
        display_image(player_dict) # player 1 at init time
        #add_game_round()
        
def display_image(player_dict):   # put image on players canvas
    global _question
    num=0
    for key, value in player_dict.items():
        if test_solved(num):
            set_form_color(sh.player)
            sh.canvas_lst[num].create_image((100, 100), image=value, anchor='center')   # remember x,y is center of image
        else:
            sh.canvas_lst[num].create_image((100, 100), image=_question, anchor='center')   # remember x,y is center of image
        num+=1

def display_random():
    '''routine which display a random image on right canvas'''
    global _rnd_img
    _rnd_img = list(sh.big_im_dict[str(sh.round_num)])[1]   # get the image from dict    
    # set current big image number from path
    temp_value=sh.big_im_dict[str(sh.round_num)][0]   # /home/halvard/Skrivebord/minnespel smaabruk/assets/lotto_graphics/1.png
    sh.cbi_value=str(temp_value.split('/')[-1]).split('.')[0]
    _w1.CanvasLotto.create_image((330, 330), image=_rnd_img, anchor='center')
    # set image text
    print('sh.cbi_value:', sh.cbi_value, type(sh.cbi_value))
    _w1.TLblExplanation.configure(foreground="#6B4322", text=sh.u_text[str(sh.cbi_value)])
    
#   ========================================================
#
#     splash screen and language routines
#   ========================================================

def set_logo_text():
    '''routine which enter logo text according to selected language'''
    textbox=_w1.TextLogo
    textbox.configure(font=sh.myFont2)
    textbox.configure(wrap="word")
    textbox.delete(1.0, "end")   # clear text
    if not sh.language: 
        txt='''   a Farm Memory game'''
    else:
        txt='''  Minnespel, småbruk'''
    textbox.insert('end', txt)

def display_splash():
    '''routine which display the splash screen'''
    global _splash
    _w1.TFrameSplash.lift()
    _w1.Scrolledtext2.place(x=2000)
    _splash = tk.Image("photo", file='assets/lotto_graphics/splash_screen.png')
    _w1.CanvasSplash.create_image((660, 330), image=_splash, anchor='center')
    fade_in()  

#   ========================================================
#
#     instruction screen routines
#   ========================================================

def display_instructions():
    '''routine which display instructions into a scrolledtextbox 
       according to selected language'''
    global _instructions
    textbox=_w1.Scrolledtext2
    _instructions = tk.Image("photo", file='assets/lotto_graphics/instructions.png')
    _w1.CanvasSplash.create_image((660, 330), image=_instructions, anchor='center')
    textbox.place(x=228)
    textbox.configure(font=sh.myFont1)
    textbox.configure(wrap="word")
    textbox.delete(1.0, "end")   # clear text
    if not sh.language:
        txt='''
                                                                     I N S T R U C T I O N S :
                       
                The small farm memory game is about finding similar pictures from the theme of
                small farms. On the left side is the player's playing board with nine playing
                card images. At the start, the playing card shows a question mark, that is the
                back of the playing card. Playing cards can be turned over with the help of a 
                click with the mouse, something about the gaongen. The card at the top left
                here, about to be turned over. Therefore change question-marked space with the
                image on the card. Is the image similar to the large image on the right?
                If the tickets are the same, the playing card is not turned over. The big thing
                the image is also replaced with a new one.
                The question mark no longer hides the image, but they don't like it
                the image will be hidden after a short time. If you manage to find similar cards,
                you get and another attempt before the next player takes over the game with his
                suit. Are you good at figuring out what kind of picture you have flipped?
                The first player to turn over all their cards has won the game.
                
                                                                                                                      Good luck!
    '''
    else:
        txt='''
                                                   I N F O R M A S J O N   O M   S P E L E T :
                       
                Minnespelet småbruk handlar om å finna like bilder frå temaet småbruk.
                På venstre sida er spelaren sitt spelebrett med ni spelekort bilder.
                I byrjinga syner spelekorta et spørsmålsteikn, det er baksida av spelekortet.
                Spelekorta kan snuast ved hjelp av klikk med musa, eit om gaongen.
                Kortet øverst til venstre her, held på å bli snudd. Derfor skiftar 
                spørsmålsteiknet plass med biletet på kortet. 
                Er biletet likt med det store biletet som er til høgre? 
                Dersom bileta er like, blir ikke spelekortet snudd tilbake. Det store 
                biletet blir også bytta ut mot eit nytt. 
                Spørsmålsteiknet gøymer ikkje lenger biletet, men er dei ikkje like vil 
                biletet bli gøymt etter kort tid. Klarer du å finna like kort får du og
                nytt forsøk før neste spelar overtar spelinga med sin farge.
                Er du dyktig til å hugse kva for bilete du har snudd?
                Første spelar som har snudd alle korta sine har vunnet spelet.
    
                                                                                                        Til lukka med spelinga!
    '''
    textbox.insert('end', txt)

def display_owl_right():
    '''routine which display a owl image on right canvas'''
    global _owl_right
    _owl_right= tk.Image("photo", file='assets/lotto_graphics/owl_right.png')
    _w1.CanvasLotto.create_image((330, 330), image=_owl_right, anchor='center')

#   ========================================================
#
#     style and color routines
#   ========================================================

def make_mystyle():
    # set TFrame style
    sh.style.map('TFrame',
                background=[('active', '#8B8878'),   # bg2),
                            ('disabled', 'gray76'),
                            ('readonly', 'firebrick2')],
                bordercolor=[('active', '#FFFAFA'),   # fg2),
                            ('disabled', 'gray24'),   # fg1),
                            ('readonly', 'gray50')]   # fg3)],
                )
    sh.style.map('TButton',
                background=[('active', '#8B8878'),
                            ('disabled', 'gray76'),
                            ('readonly', 'firebrick2')],
                foreground=[('active', '#FFFAFA'),
                            ('disabled', 'gray24'),
                            ('readonly', 'gray50')]
                )    

def set_form_color(player):
    # change background color to player color
    sh.style.configure('MyTFrame.TFrame',
                    background=sh.form_color_lst[player],
                    bordercolor='gray24')
    _w1.TFrame1.configure(style='MyTFrame.TFrame')

def set_button_color():
    for inx, button in enumerate(sh.button_lst):
        sh.style.configure(sh.id_lst[inx],
                    background='#8B8878',
                    foreground=sh.form_color_lst[inx]
                        )
        button.configure(style=sh.id_lst[inx])

#   ========================================================
#
#     Entry Box input validation routines
#   ========================================================

def validate_input1(*args):
    # start validating this entry
    validate_input(_w1.player1var)
    
def validate_input2(*args):
    # start validating this entry
    validate_input(_w1.player2var)

def validate_input3(*args):
    # start validating this entry
    validate_input(_w1.player3var)

def validate_input4(*args):
    # start validating this entry
    validate_input(_w1.player4var)

def validate_input(player_var):
    # Get the current value of the entry
    input_value = player_var.get()
    # Check if the input is a number
    if input_value.isdigit():
        pass
    else:
        if input_value.endswith(" "):   # space not allowed
            player_var.set('')
        elif input_value.isalpha():     # letter is allowed
            if input_value.istitle():   # first letter must be capitalized
                pass
                #print(f"Input: {input_value} (Word)")
            else:
                player_var.set('')
        else:
            player_var.set('')

#   ========================================================
#
#     set widget focus logic routines
#   ========================================================

def retur_entry1(*args):
    _w1.TEntry1.tk_focusNext().focus_set()
    _w1.TEntry1.config(takefocus=1)

def retur_entry2(*args):
    _w1.TEntry2.tk_focusNext().focus_set()
    _w1.TEntry2.config(takefocus=1)

def retur_entry3(*args):
    _w1.TEntry3.tk_focusNext().focus_set()
    _w1.TEntry3.config(takefocus=1)

def retur_entry4(*args):
    _w1.TBtnGoOn.focus_set()   # tk_focusNext().focus_set()
    _w1.TBtnGoOn.config(takefocus=1)

#   ========================================================
#
#     slide one image into another image using gif routines
#   ========================================================

def slide(which):
    thisPath=sh.path_photo
    print('... ', sh.player, type(sh.player))
    if sh.player > 4:
        sh.player = 1
    im_carrier=eval(f'sh.player{sh.player+1}_im_np[str({which})]')
    
    a_image = im_carrier
    image_back = sh.quest_name
    temp_gif = "/test.gif"
    imList=[a_image, image_back, temp_gif]
    if not sh.direction:        
        process_images(f"{imList[0]}", f"{imList[1]}", f"{thisPath}{imList[2]}")   # --> -4-
        # Display gif, discover
        displayfile(f"{thisPath}{imList[2]}")   # --> -6-
        sh.direction=1
    else:
        process_images(f"{imList[1]}", f"{imList[0]}", f"{thisPath}{imList[2]}")   # --> -4-
        # Display gif back hide againspill
        displayfile(f"{thisPath}{imList[2]}")   # --> -6-
        sh.direction=0

def process_images(image1_path, image2_path, output_gif_path, num_frames=10):
    # Open the images
    thumbnail_size=(200,200)
    im1=Image.open(image1_path)
    im1=purePilAlpha2colorV2(im1, color=(255, 255, 255))
    im2=Image.open(image2_path)
    im2=purePilAlpha2colorV2(im2, color=(255, 255, 255))
    im1.thumbnail(thumbnail_size)
    im2.thumbnail(thumbnail_size)
    image1 = np.array(im1)
    image2 = np.array(im2)
    # Ensure both images have the same size
    assert image1.shape == image2.shape, "Images must have the same dimensions."
    # Create a GIF file
    gif_frames = []
    # Generate frames by sliding image2 over image1
    for offset in np.linspace(0, image1.shape[1], num_frames, dtype=int):
        processed_matrix = slide_images(image1, image2, offset)
        # Create an image from the processed data
        gif_frames.append((processed_matrix).astype(np.uint8))
    # Save the frames as a GIF using imageio
    with imageio.get_writer(output_gif_path, mode='I', duration=0.1) as writer:
        for frame in gif_frames:
            writer.append_data(frame)

def purePilAlpha2colorV2(image, color=(255, 255, 255)):
    '''convert RGBA image mode to RGB'''
    """Alpha composite an RGBA Image with a specified color.
    Source: http://stackoverflow.com/a/9459208/284318
    Keyword Arguments:
    image -- PIL RGBA Image object
    color -- Tuple r, g, b (default 255, 255, 255)
    """
    #print('image.mode:', image.mode, type(image.mode))
    if image.mode=="RGB":   # did not need converting
        return image
    image.load()  # needed for split()
    background = PIL.Image.new("RGB", image.size, '#d9d9d9')
    background.paste(image, mask=image.split()[3])  # 3 is the alpha channel
    return background

def slide_images(image1, image2, offset):
    # Slide image2 over image1 by the specified offset
    width, height, channels = image1.shape
    result = np.zeros_like(image1)
    if offset >= 0:
        result[:, :width-offset] = image1[:, offset:]
        result[:, width-offset:] = image2[:, :offset]
    else:
        result[:, -offset:] = image1[:, :offset]
        result[:, :-offset] = image2[:, -offset:]
    return result

def displayfile(filename):
    global _top1, _w1, frames, _image
    file = Image.open(filename)
    frameCnt = number_of_frames(file)
    frames = [tk.PhotoImage( file=filename, format = f'gif -index {i}')
                for i in range(frameCnt)]
    update(0)

def number_of_frames(gif):
    "Prints and returns the number of frames of the gif"
    return gif.n_frames

def update(ind):
    global _top1, frames
    try:
        frame = frames[ind]
        ind += 1
        sh.can.create_image((100, 100), image=frame, anchor='center')
        root.after(45, update, ind)   # duration of image shift
    except:
        pass

#   ========================================================
#
#     runtime logic routines
#   ========================================================

def add_game_round():   # legg til spelerunde
    global _im
    
    # is the selected game board image the same as the large image on the right?
    #   yes;
    #       if there are more pictures, return to the start of this routine
    #       else: quit
    #   no;
    #       next player, and change color

    
    #is_solved()   # check if two images is equal
    
    if sh.round_num < 37:
        sh.round_num+=1

    #display_random()   # temporarily until sh.equal is in place

    if sh.new_round:
        # change big image
        sh.players_turn+=1
        if sh.players_turn==5:
            sh.players_turn=1

        
        set_form_color(sh.players_turn)
        player_dict=sh.player_lst[sh.players_turn]
        display_image(player_dict) # player 1 at init time
    
        # change to players color

#   ========================================================
#
#     roundup routines
#   ========================================================

def remove_tmp_file():
    '''removes share.py file created by the program while running'''
    filename = f"{module_name}.py"
    try:
        import os
        os.remove(filename)   # remove files
        print(f'   Temperary file is removed ')
    except:
        print(f'   Can not remove file: {filename}, sorry!')

def cleanUp():
    '''Calculates the Time Spent and Notifies that the App is Finished.
       Can Optionally Remove Tempered Files.'''
    # import datetime
    print('='*sh.decoration, '\n')
    print('Roundup...')
    if not sh.language:
        _show('Ends', 'Sorry!\nNow the game is over.')
    else:
        _show('Avskjedmelding', 'Programmet er no avslutta!')
    # give finish time
    current_time = datetime.datetime.now()
    current_time_2 = f'{current_time.hour:02}:{current_time.minute:02}:{current_time.second}'
    h1,m1,s1 = sh.current_time_1.split(':')
    h2,m2,s2 = current_time_2.split(':')
    tot_h=int(h2)-int(h1)
    tot_m=int(m2)-int(m1)
    tot_s=int(s2)-int(s1)
    if tot_s < 0:
        tot_m-=1
        tot_s=60+tot_s
    if tot_m < 0:
        tot_h-=1
        tot_m=60+tot_m
    tot_time=f'{tot_h:02}:{tot_m:02}:{tot_s:02}'
    print(f'   finish time : {current_time_2}')
    print('   time used   :', tot_time )
    remove_tmp_file()
    
    print('Done.')

#   ========================================================
#     call back routine section
#   ========================================================

def turn_card(*args):   # after using mouse on canvas
    if _debug:
        print('gameboard_support.game_round')
        for arg in args:
            print ('    another arg:', arg)
        sys.stdout.flush()
    which= arg   # which canvas is visited
    print('this is card:', which)
    on_slide(which)   # slide from back to image
    is_solved(which)

def on_slide(*args):
    if _debug:
        print('gameboard_support.on_slide')
        for arg in args:
            print ('    another arg:', arg)
        sys.stdout.flush()
    which=arg
    #print('..... def on_slide -- which:', which)
    if which==1:
        sh.can=sh.can1
        slide(which)
    elif which==2:
        sh.can=sh.can2
        slide(which)
    elif which==3:
        sh.can=sh.can3
        slide(which)
    elif which==4:
        sh.can=sh.can4
        slide(which)
    elif which==5:
        sh.can=sh.can5
        slide(which)
    elif which==6:
        sh.can=sh.can6
        slide(which)
    elif which==7:
        sh.can=sh.can7
        slide(which)
    elif which==8:
        sh.can=sh.can8
        slide(which)
    elif which==9:
        sh.can=sh.can9
        slide(which)

def on_Rbtn(*args):
    if _debug:
        print('gameboardlotto_support.on_Rbtn')
        for arg in args:
            print ('    another arg:', arg)
        sys.stdout.flush()
    result = _w1.selectedButton.get()
    print(result, type(result))
    if result:   # Norwegian
        print('Norsk språkføre er valgt')
        sh.language=1
        set_logo_text()
        init_language_text()
    else:
        print('The English language setting is selected')
        sh.language=0
        set_logo_text()
        init_language_text()

def on_TBtnNext(*args):
    if _debug:
        print('gameboardlotto_support.on_TBtnNext')
        for arg in args:
            print ('    another arg:', arg)
        sys.stdout.flush()
    if sh.next == 1:
        sh.next+=1
        #_w1.TBtnNext.place(x=110, y=10, height=35, width=74)   # x=145
        _w1.TRadiobutton1.destroy()
        _w1.TRadiobutton2.destroy()
        display_instructions()
        fade_in()
    elif sh.next == 2:
        _w1.TFrame2.place(x=685)
        _w1.menubar.entryconfigure("__________________", label="Minnespel, småbruk", foreground="#F4D921")
        _w1.TFrameSplash.destroy()
        _w1.TEntry1.focus()
        _w1.TEntry1.config(takefocus=1)
        _w1.TBtnNext.destroy()
        _w1.FrameLanguage.destroy()
        _w1.menubar.entryconfigure("_____________", label=f"start:  kl.{sh.current_time_1[0:5]}", foreground="#2F5490")

def init_path():
    # parent dir path
    sh.path_parent = os.getcwd()
    # photo dir path
    sh.path_photo = sh.path_parent+"/assets/lotto_graphics"

def init_canvas():
    sh.can1 = _w1.Canvas1
    sh.can2 = _w1.Canvas2
    sh.can3 = _w1.Canvas3
    sh.can4 = _w1.Canvas4
    sh.can5 = _w1.Canvas5
    sh.can6 = _w1.Canvas6
    sh.can7 = _w1.Canvas7
    sh.can8 = _w1.Canvas8
    sh.can9 = _w1.Canvas9
    sh.canvas_lst = [sh.can1, sh.can2, sh.can3, 
                     sh.can4, sh.can5, sh.can6, 
                     sh.can7, sh.can8, sh.can9]

def on_preferences(*args):
    if _debug:
        print('gameboardlotto_support.on_preferences')
        for arg in args:
            print ('    another arg:', arg)
        sys.stdout.flush()

#---temp start----------------

def on_TBtnPlayer1(*args):
    if _debug:
        print('fourplayer_support.on_TBtnPlayer1')
        for arg in args:
            print ('    another arg:', arg)
        sys.stdout.flush()
    sh.player=0
    player_dict=sh.player_lst[sh.player]
    set_form_color(sh.player)
    display_image(player_dict)

def on_TBtnPlayer2(*args):
    if _debug:
        print('fourplayer_support.on_TBtnPlayer2')
        for arg in args:
            print ('    another arg:', arg)
        sys.stdout.flush()
    sh.player=1
    player_dict=sh.player_lst[sh.player]
    set_form_color(sh.player)
    display_image(player_dict)

def on_TBtnPlayer3(*args):
    if _debug:
        print('fourplayer_support.on_TBtnPlayer3')
        for arg in args:
            print ('    another arg:', arg)
        sys.stdout.flush()
    sh.player=2
    player_dict=sh.player_lst[sh.player]
    set_form_color(sh.player)
    display_image(player_dict)

def on_TBtnPlayer4(*args):
    if _debug:
        print('fourplayer_support.on_TBtnPlayer4')
        for arg in args:
            print ('    another arg:', arg)
        sys.stdout.flush()
    sh.player=3
    player_dict=sh.player_lst[sh.player]
    set_form_color(sh.player)
    display_image(player_dict)

#---temp end-------------------

def on_TBtnGoOn(*args):
    if _debug:
        print('nameplayers_support.on_TBtnGoOn')
        for arg in args:
            print ('    another arg:', arg)
        sys.stdout.flush()
    # read player 1    
    sh.player_name[1]=_w1.player1var.get()
    if not len(sh.player_name[1])==0:
        pass ##_w1.TBtnPlayer1.configure(text=sh.player_name[1])
    else:
        pass ##_w1.TBtnPlayer1.destroy()
    # read player 2
    sh.player_name[2]=_w1.player2var.get()
    if not len(sh.player_name[2])==0:
        pass ##_w1.TBtnPlayer2.configure(text=sh.player_name[2])
    else:
        pass ##_w1.TBtnPlayer2.destroy()
    # read player 3
    sh.player_name[3]=_w1.player3var.get()
    if not len(sh.player_name[3])==0:
        pass ## _w1.TBtnPlayer3.configure(text=sh.player_name[3])
    else:
        pass ## _w1.TBtnPlayer3.destroy()
    # read player 4
    sh.player_name[4]=_w1.player4var.get()
    if not len(sh.player_name[4])==0:
        pass ##_w1.TBtnPlayer4.configure(text=sh.player_name[4])
    else:
        pass ##_w1.TBtnPlayer4.destroy()
    # remove the lid over players button
    #_w1.TLblLid.destroy()
    # lift the canvas frame to top
    _w1.TFrame1.lift()
    # remove the owl image
    _w1.CanvasLotto.delete("all")
    # display first lotto card
    display_random()   # display a random image on CanvasLotto
    add_game_round()

def on_TBtnExit(*args):
    if _debug:
        print('nameplayers_support.on_TBtnExit')
        for arg in args:
            print ('    another arg:', arg)
        sys.stdout.flush()
    cleanUp()
    sys.exit()

#   ========================================================
#     call main application
#   ========================================================

if __name__ == '__main__':
    minnespel_smaabruk.start_up()
