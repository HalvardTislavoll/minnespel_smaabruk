#! /usr/bin/env python3
#  -*- coding: utf-8 -*-
#
# Support module generated by PAGE version 8.0
#  in conjunction with Tcl version 8.6
#    Jan 06, 2024 01:58:52 PM CET  platform: kwargsLinux
#    Jan 08, 2024 09:39:21 AM CET  platform: Linux
#    Jan 10, 2024 06:05:47 PM CET  platform: Linux
#    Jan 10, 2024 09:12:40 PM CET  platform: Linux
#    Jan 25, 2024 06:19:20 PM CET  platform: Linux
#    Jan 31, 2024 12:17:06 PM CET  platform: Linux
#    Jan 31, 2024 01:07:16 PM CET  platform: Linux
#    Feb 09, 2024 02:00:39 PM CET  platform: Linux
#    Feb 20, 2024 10:24:27 PM CET  platform: Linux
#    Feb 29, 2024 04:14:11 PM CET  platform: Linux
#    Mar 07, 2024 08:45:30 AM CET  platform: Linux
#
#       What remains to be done:  ☐ ☑ ☒
#
#  ☐  debug, check for logical gaps and improve code
#  ☐  on_Rbtn() -- put all language items into this rutine and change text
#  ☐  change playing board after each move
#  ☐  create a progress bar that visualizes the time for turning over cards
#  ☐  create a menu bar class that places the time, name and title with the change option
#     adjust space according to font size and text length
#  ☐  game board subtitle color = game board color and menu line name color

#   ========================================================
#
#     MODULE IMPORT SECTION
#   ========================================================

import sys
import tkinter as tk
import tkinter.ttk as ttk
from tkinter.constants import *

import minnespel_smaabruk

# Importing other required modules
try:
    from tkinter import font
    from tkinter import messagebox
    from tkinter.messagebox import _show
    import random
    import datetime
    import os
    import platform
    import PIL   
    from PIL import Image, ImageTk
    import numpy as np
    import imageio
    from screeninfo import get_monitors
    import datetime
    from time import sleep
    import tomli
    import tomli_w
    import json
except:
    # can't import essential modules
    sys.exit()

#   --------------------------------------------------------
#     Create shared module and import it into the script
#   --------------------------------------------------------
module_name = "shared"   # empty_module
# Create the empty module file
with open(f"{module_name}.py", "w") as file:
    pass  # This creates an empty file
# Check if the file exists before importing
if os.path.isfile(f"{module_name}.py"):
    import importlib.util
    spec = importlib.util.spec_from_file_location(module_name, f"{module_name}.py")
    module = importlib.util.module_from_spec(spec)
    spec.loader.exec_module(module)
else:
    print(f"File '{module_name}.py' does not exist. Failed to import the module.")
sh=importlib   # sh is alias shared for short
#   ---end create shared module-----------------------------

_version = "0.5.0"
_debug = True # False to eliminate de_w1.Scrolledtext2.bug printing from callback functions.
_activate_config = False   # activate the toml file during runtime

#   ========================================================
#
#     STARTUP ROUTINES SECTION
#   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

def main(*args):                            # statup routin from PAGE
    '''Main entry point for the application.'''
    global root
    root = tk.Tk()
    root.protocol( 'WM_DELETE_WINDOW' , root.destroy)
    # Creates a toplevel widget.
    global _top1, _w1
    _top1 = root
    _w1 = minnespel_smaabruk.Toplevel1(_top1)
    minnespel_smaabruk_startup()            # my code starts here
    root.mainloop()

def minnespel_smaabruk_startup():           # my starting point for this appliction
    # a memory game of own images and using four game board
    _top1.title("a Farm Memory game")   # give a a catchy name to this app
    # orderd the frame level to show up correct because working with frames in Page change order
    sh.lift_wid = [_w1.TFrameLotto, _w1.TFrame1, _w1.TFrame3, _w1.TFrameSplash, _w1.FrameLanguage]
    wid_lift()
    # set different font options
    sh.myFont0 = font.Font(family="Ubuntu", size=16)
    sh.myFont1 = font.Font(family="Ubuntu", size=20)
    sh.myFont2 = font.Font(family="Ubuntu", size=30)
    sh.myFont3 = font.Font(family="TlwgTypewriter", size=20)
    # show instruction at startup ?   # 0 = False, 1 = True
    sh.show_instruction = 1
    # set screen active   
    sh.splash_screen = 1
    sh.player_registration = 1
    sh.game_board = 1
    # locale init language.   'en' is english and 'no' is norwegian
    locale = 'en'
    match locale:
        case 'en':
            sh.language = 0
        case 'no':
            sh.language = 1
    # load translation .json file
    get_language()
    # centers the program form on the screen 
    put_toplevel_on_center()
    # display an avatar on the taskbar
    ## taskbar_icon()   # can not be used if using fade() in Linuxmint
    # place the Terminal from down to the left side on screen
    terminal_place()
    # set decoration line length for use in Therminal  
    sh.decoration = 53
    # make items on menubar invisible
    menubar_invisible()
    # set widgets state   
    wid_state()
    # set widgets place
    wid_place()
    # set widgets start value and init the player's card canvas 
    wid_init()
    
    init_var()
    sysem_info()
    
    set_logo_text()    
    display_splash()   # display an centered image on canvas for 5 seconds
    
    small_image_back_subtitle()
    _w1.selectedButton.set(sh.language)
    _w1.TCheckbuttonDisplay.place(x=2000)   # (move away for now)
    # set up variables using a configuration file.
    
    if _activate_config:
        from_toml() 
        _w1.tch47.set(sh.show_instruction)
    else:
        _w1.tch47.set(1)
        sh.using_config = _w1.tch47.get()
        # to make a config.toml file
        #config=init_toml()
        #to_toml(config)
    owl_teach()
    display_owl_right()
    init_bindings()
    player_dict=sh.player_lst[sh.player]
    display_image(player_dict) # player 1 at init time

def init_var():                             # set most of variables
    set_flag()
    sh.labeltxt = " "*21
    sh.spalsh_delay = 250
    sh.memo_delay = 2000   # 2 sec.
    
    sh.direction = 0
    sh.labeltxt = ""
    sh.old_labeltxt = "cur_user"
    sh.cbi_value = 1      # current big image
    sh.cti_value = 1      # current tumbnail image

    sh.im_dict = {}     # a dict to hold all thumbnail images from disc
    sh.rnd_im_dict={}   # a dict to hold all images in random orderinit_players_image_dict(sh.rnd_im_dict)
    sh.big_im_dict = {}   # a dict to hold all raw images from dict 
    sh.big_im_random_dict = {}

    sh.player = 0
    sh.player_name = {}
    sh.players_turn = sh.player

    sh.round_num = 0
    sh.new_round = True
    
    # init a image dict for each player
    sh.player1_im = {}
    sh.player2_im = {}
    sh.player3_im = {}
    sh.player4_im = {}
    
    sh.player1_im_np = {}
    sh.player2_im_np = {}
    sh.player3_im_np = {}
    sh.player4_im_np = {}

    sh.player_lst = [sh.player1_im, sh.player2_im, sh.player3_im, sh.player4_im]

    sh.player1_solved = {'0':0, '1':0, '2':0,
                         '3':0, '4':0, '5':0,
                         '6':0, '7':0, '8':0}
    sh.player2_solved = {'0':0, '1':0, '2':0,
                         '3':0, '4':0, '5':0,
                         '6':0, '7':0, '8':0}
    sh.player3_solved = {'0':0, '1':0, '2':0,
                         '3':0, '4':0, '5':0,
                         '6':0, '7':0, '8':0}
    sh.player4_solved = {'0':0, '1':0, '2':0,
                         '3':0, '4':0, '5':0,
                         '6':0, '7':0, '8':0}
   
    sh.form_color_lst = ['#041d62','#f3d012','#960a0a','#345306']   # blue,yellow,red,green
    random.shuffle(sh.form_color_lst)
    _w1.Label1.configure(background = sh.form_color_lst[0])
    _w1.Label2.configure(background = sh.form_color_lst[1])
    _w1.Label3.configure(background = sh.form_color_lst[2])
    _w1.Label4.configure(background = sh.form_color_lst[3])
    sh.style = ttk.Style()
    make_mystyle()
 
    set_form_color(sh.player)
    ## set_button_color()
    init_path()
    # do not init this before player registration
    img_number = 36   # set number of images to load
    # make a list of all image names by List Comprehension
    sh.im_lst = [f'{x}.png' for x in range(1,img_number+1)]
    ## print(im_lst)   # ['1.png', '2.png', '3.png', '4.png', '5.png', '6.png', '7.png', '8.png', '9.png', '10.png', '11.png', '12.png', '13.png', '14.png', '15.png', '16.png', '17.png', '18.png', '19.png', '20.png', '21.png', '22.png', '23.png', '24.png', '25.png', '26.png', '27.png', '28.png', '29.png', '30.png', '31.png', '32.png', '33.png', '34.png', '35.png', '36.png']
    init_image_dict()
    sh.rnd_im_dict = dict_randomization(sh.im_dict)
    init_players_image_dict(sh.rnd_im_dict)
    global _question
    # set playbutton back
    fn = "owl_book.png"
    photo_location = os.path.join(sh.path_photo,fn)
    sh.quest_name = photo_location
    quest = Image.open(photo_location)
    thumbnail_size = (200,200)
    quest.thumbnail(thumbnail_size)   # 600x600 -> 200x200
    _question = ImageTk.PhotoImage(quest)
    sh.big_im_dict = dict_randomization(sh.big_im_dict)
    set_image_back()

def set_language():
    # get a dict of u_text
    if sh.language:   # == 'no'
        # set widget language text
        _w1.TCheckbuttonDisplay.configure(text=f"{sh.language_no['TCheckbuttonDisplay_txt']}")
        _w1.TLabel5.configure(text=f'{sh.language_no["TLabel5_txt"]}')
        _w1.TLabel1.configure(text=f'{sh.language_no["TLabel1_txt"]}')
        _w1.TLabel2.configure(text=f'{sh.language_no["TLabel2_txt"]}')
        _w1.TLabel3.configure(text=f'{sh.language_no["TLabel3_txt"]}')
        _w1.TLabel4.configure(text=f'{sh.language_no["TLabel4_txt"]}')
        _w1.TButtonDismiss.configure(text=f'{sh.language_no["TButtonDismiss_txt"]}')
        _w1.TBtnNext.configure(text=f'{sh.language_no["TBtnNext_txt"]}')
        _w1.TBtnGoOn.configure(text=f'{sh.language_no["TBtnGoOn_txt"]}')
        # set text
        sh.guidance_txt = f'{sh.language_no["guidance_txt"]}'   
        sh.u_text = sh.language_no['u_text']
        sh.about_txt = f"{sh.language_no['about_txt']}"
        sh.instruction_txt = f"{sh.language_no['instruction_txt']}"
    else:
        # set widget language txt
        _w1.TCheckbuttonDisplay.configure(text=f"{sh.language_en['TCheckbuttonDisplay_txt']}")
        _w1.TLabel5.configure(text=f'{sh.language_en["TLabel5_txt"]}')
        _w1.TLabel1.configure(text=f'{sh.language_en["TLabel1_txt"]}')
        _w1.TLabel2.configure(text=f'{sh.language_en["TLabel2_txt"]}')
        _w1.TLabel3.configure(text=f'{sh.language_en["TLabel3_txt"]}')
        _w1.TLabel4.configure(text=f'{sh.language_en["TLabel4_txt"]}')
        _w1.TButtonDismiss.configure(text=f'{sh.language_en["TButtonDismiss_txt"]}')
        _w1.TBtnNext.configure(text=f'{sh.language_en["TBtnNext_txt"]}')
        _w1.TBtnGoOn.configure(text=f'{sh.language_en["TBtnGoOn_txt"]}')
        # set text
        sh.guidance_txt = f'{sh.language_en["guidance_txt"]}'
        sh.u_text = sh.language_en['u_text']
        sh.about_txt = f"{sh.language_en['about_txt']}"
        sh.instruction_txt = f"{sh.language_en['instruction_txt']}"
    if sh.splash_screen:
        set_logo_text()
    # test: change text in tooltip 
    _w1.TEntry1_tooltip.configure(text='''Bruk stor bokstav først''')

def wid_init():
    _w1.TLblExplanationBig.configure(text="")
    # set the player's card canvas
    sh.can1 = _w1.Canvas1
    sh.can2 = _w1.Canvas2
    sh.can3 = _w1.Canvas3
    sh.can4 = _w1.Canvas4
    sh.can5 = _w1.Canvas5
    sh.can6 = _w1.Canvas6
    sh.can7 = _w1.Canvas7
    sh.can8 = _w1.Canvas8
    sh.can9 = _w1.Canvas9
    sh.canvas_lst = [sh.can1, sh.can2, sh.can3, 
                     sh.can4, sh.can5, sh.can6, 
                     sh.can7, sh.can8, sh.can9]

def wid_place():
    _w1.TFrame2.place(x=2000)
    _w1.TFrame5.place(x=2000)
    _w1.TFrameInfo.place(x=2000)
    #_w1.TFrameInfo.place(x=240, y=137, height=600, width=915)
    _w1.TFramePreferences.place(x=2000)
    _w1.FrameLanguage.place(x=2000)
    _w1.TCheckbuttonDisplay.place(x=2000)
    '''
    self.TCheckbuttonDisplay = ttk.Checkbutton(self.CanvasSplash)
    self.TCheckbuttonDisplay.place(x=990, y=530, width=141, height=23)
    '''

def wid_lift():
    for wid in sh.lift_wid:
        wid.lift()

def set_flag():
    sh.menubar_player=False

def wid_state():
    _w1.menubar.entryconfig("H", state="disabled")

def init_path():                            # set path to images
    # parent dir path
    sh.path_parent = os.getcwd()
    # photo dir path
    sh.path_photo = sh.path_parent+"/assets/lotto_graphics"

def init_image_dict():                      # read all images into dict
    # make a dicts with all images
    sh._img=[]
    sh.img_np=[]
    global _img
    for inx, im in enumerate(sh.im_lst):
        if inx < 36:
            # join path and filename to photo_location for a photo
            fn = im
            photo_location = os.path.join(sh.path_photo,fn)
            sh.img_np.append(photo_location)
            #loading the image 
            original = Image.open(photo_location)
            sh.big_im_dict[str(inx)]=(photo_location, ImageTk.PhotoImage(original))
            # create a thumbnail
            thumbnail_size=(200,200)
            original.thumbnail(thumbnail_size)   # 600x600 -> 200x200
            sh._img.append(inx+1)
            sh._img[inx] = ImageTk.PhotoImage(original)
            # save original thumbnail to dict
            _img=f'{sh._img[inx]}'
            if not _img in sh.im_dict:
                sh.im_dict[_img] = (photo_location, ImageTk.PhotoImage(original), inx)

def init_players_image_dict(rnd_im_dict):   # the players' related pictures
    # split dict into four equal chunks
    cnt=1
    for key, values in rnd_im_dict.items():
        if cnt==1:
            sh.player1_im[key]=values
        elif cnt==2:
            sh.player2_im[key]=values
        elif cnt==3:
            sh.player3_im[key]=values
        elif cnt==4:
            sh.player4_im[key]=values
        cnt+=1
        if cnt==5:
            cnt=1
    cnt=1
    key1='1'
    key2='1'
    key3='1'
    key4='1'
    key5='1'
    key6='1'
    key7='1'
    key8='1'
    key9='1'
    for inx, values in enumerate(sh.random_img_np):
        if cnt==1:
            sh.player1_im_np[key1]=values
            temp=int(key1)
            temp+=1
            key1=str(temp)
        elif cnt==2:
            sh.player2_im_np[key2]=values
            temp=int(key2)
            temp+=1
            key2=str(temp)
            key2=str(key2)
        elif cnt==3:
            sh.player3_im_np[key3]=values
            temp=int(key3)
            temp+=1
            key3=str(temp)
            key3=str(key3)
        elif cnt==4:
            sh.player4_im_np[key4]=values
            temp=int(key4)
            temp+=1
            key4=str(temp)
            key4=str(key4)
        cnt+=1
        if cnt==5:
            cnt=1

def init_bindings():                        # set bindings to root and canvases
    # set binding to Go On button
    _w1.TBtnGoOn.bind('<Return>', on_TBtnGoOn)
    # set binding to entry/return key
    _w1.TEntry1.bind('<Return>', retur_entry1)
    _w1.TEntry2.bind('<Return>', retur_entry2)
    _w1.TEntry3.bind('<Return>', retur_entry3)
    _w1.TEntry4.bind('<Return>', retur_entry4)
    # Trace changes in the entry value
    _w1.player1var.trace_add("write", validate_input1)
    _w1.player2var.trace_add("write", validate_input2)
    _w1.player3var.trace_add("write", validate_input3)
    _w1.player4var.trace_add("write", validate_input4)
    # make canvases turnable
    sh.can1.bind('<Button-1>', lambda e: turn_card(e,1))
    sh.can2.bind('<Button-1>', lambda e: turn_card(e,2))
    sh.can3.bind('<Button-1>', lambda e: turn_card(e,3))
    sh.can4.bind('<Button-1>', lambda e: turn_card(e,4))
    sh.can5.bind('<Button-1>', lambda e: turn_card(e,5))
    sh.can6.bind('<Button-1>', lambda e: turn_card(e,6))
    sh.can7.bind('<Button-1>', lambda e: turn_card(e,7))
    sh.can8.bind('<Button-1>', lambda e: turn_card(e,8))
    sh.can9.bind('<Button-1>', lambda e: turn_card(e,9))
    root.bind("<Key-Control_L><Key-Alt_L><Key-m>", lambda e: menu_state(e,1))   # to activate menu
    root.bind("<Key-Control_L><Key-Alt_L><Key-d>", lambda e: menu_state(e,2))   # to disable menu 

def sysem_info():                           # put system info into Terminal
    '''routine which write information about this application in terminal'''
    # remember to update myFile !!!
    # get system info
    current_user = os.environ.get('USER', os.environ.get('USERNAME'))
    py_f_name =    os.path.basename(sys.argv[0])
    current_path = os.path.abspath(__file__)
    py_version =   platform.python_version()
    author =       'Halvard Tislavoll'
    licence =      'MIT'
    current_time = datetime.datetime.now()
    sh.current_time_1 = f'{current_time.hour:02}:{current_time.minute:02}:{current_time.second}'
    # read this file and get page version on line 4
    myFile="./minnespel_smaabruk_support.py"
    signal, all_text=read_text_file_lines(myFile)
    if signal:
        txt_lst=all_text.split('\n')
        sh.page_version=txt_lst[4][-4:]   # list out last of a function line, the "8.0G" from "... PAGE version 8.0G"
        # It is in line 4 but count from 0 it is 3
    else:
        print('Trouble, no _support file is found. Have you give the right name?')
    # print system info
    print()
    print(f'{current_time.year}-{current_time.month}-{current_time.day}')
    print()
    print(f'    © Copyright : {author}, 2024')
    print(f'    licence     : {licence}')
    print(f'    file running: {py_f_name}, version {_version}')
    print(f'    current path: {current_path}')
    print(f'    current user: {current_user}')
    print(f'    Python ver. : {py_version}')        
    print(f'    GUI is constructed using PAGE version {sh.page_version}')
    print()
    print(f'{sh.current_time_1}  ...start up')
    print('-'*sh.decoration, '\n')

#   ========================================================
#
#     STARTUP ROUTINES SUPPORTING SECTION
#   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

def menubar_invisible():
    # set space menuitems dissabled
    _w1.menubar.entryconfigure("space1",   font="-family {TlwgTypewriter} -size 10 -weight bold")
    _w1.menubar.entryconfigure("space1",   label=" "*1, )
    _w1.menubar.entryconfigure("space2",   font="-family {TlwgTypewriter} -size 10 -weight bold")
    _w1.menubar.entryconfigure("space2",   label=" "*25, state="disabled")
    _w1.menubar.entryconfigure("space3",   label=" "*78, font="-family {TlwgTypewriter} -size 10 -weight bold", state="disabled")
    _w1.menubar.entryconfigure("clock",    label=" "*11, state="disabled")
    _w1.menubar.entryconfigure("cur_user", label=" "*21, state="disabled")   # current_user
    _w1.menubar.entryconfigure("title",    label=" "*22, state="disabled")

def menubar_player_update():
    sh.labeltxt = playername_fix(f'{sh.player_name[sh.player+1]}')

    if not sh.menubar_player:
        _w1.menubar.entryconfigure(sh.old_labeltxt,
                                   label=sh.labeltxt,
                                   foreground=str(sh.form_color_lst[sh.player])
                                  )
        sh.menubar_player = True
    else:
        _w1.menubar.entryconfigure(sh.old_labeltxt,
                                   label=sh.labeltxt,
                                   foreground=str(sh.form_color_lst[sh.player])
                                  )
    _w1.TLblExplanationLittle.configure(foreground=str(sh.form_color_lst[0]))
    sh.old_labeltxt = sh.labeltxt

def menubar_title_update():
    pass

def playername_fix(nme):
    '''Let the name be in the middle of 25'''
    name_length=len(nme)   # font length 
    field_length=25
    length = field_length%2
    #quotient, remainder = divmod(dividend, divisor)
    quotient1, remainder1 = divmod(field_length, 2)
    quotient2, remainder2 = divmod(name_length, 2)
    sp1 = quotient1-remainder1-quotient2
    sp1_txt = ' '*(sp1+remainder1)
    sp2_txt = ' '*(sp1+remainder2)
    if remainder2 == 0:
        # "even"
        txt = sp1_txt + nme + sp2_txt+'  ' 
    else:
        # "odd"
        txt = sp1_txt + nme + sp2_txt 
    return txt

def dict_randomization(d):
    ''' How To Iterate Over A Python Dictionary In Random Order? 
        To iterate over the dictionary items in random order get 
        the list of items in a tuple with .items() 
        then shuffle and iterate through this list using 
        the shuffle() and make a new dict with the result'''
    rnd_d={}
    items = list(d.items()) # List of tuples of (key,values)
    random.shuffle(items)
    make_random_np(items)   # list after shuffle
    for key, value in items:
        # print(key, ":", value)
        rnd_d[key]=value
    return rnd_d

def make_random_np(shuffled_list):
    # Enumerate to create a list of tuples (original_index, value)
    original_order = list(enumerate(shuffled_list))
    # Sort the list based on the values to get the original order
    original_order.sort(key=lambda x: x[1])
    # Extract the original indices from the sorted list
    order_of_shuffled_list = [index for index, _ in original_order]
    ## make a random np list of shuffled 'sh.img_np' by 'sh.rnd_im_dict'
    original_list = sh.img_np
    order_list = order_of_shuffled_list
    # Zip the two lists together
    zipped_lists = list(zip(order_list, original_list))
    # Sort based on the order_list
    zipped_lists.sort()
    # Extract the elements from the sorted list
    result_list = [element for _, element in zipped_lists]
    # populate sh.random_img_np with result_list 
    sh.random_img_np = result_list
    # likewise make sh.big_im_dict in random order
    zipped_lists = list(zip(order_list, sh.big_im_dict))
    zipped_lists.sort()
    sh.big_im_random_dict = [element for _, element in zipped_lists]

def taskbar_icon():                         # place a icon (avatar)
    '''routine to place avatar icon on taskbar'''
    # by G.D. Walters
    p1 = tk.Image("photo", file='assets/graphic/avatar.png')
    root.tk.call('wm', 'iconphoto', root._w, p1)

def set_image_back():
    sh.im_back = os.path.join(sh.path_photo,"owl_book.png")

def terminal_place():                       # Terminal place on screen
    '''routine to clean up the display during debug runtime, else hide terminal window'''
    if _debug:
        # put the Terminal form to left edge (usfull when using Geany IDE)
        import pyautogui
        pyautogui.hotkey('win','left','down')
    else:
        # minimize the Terminal form
        import pyautogui
        pyautogui.hotkey('alt','f10')   # maximize Terminal form first
        pyautogui.moveTo(1840,17, duration=0.2)   # go to minimize button
        pyautogui.doubleClick()   # minimize

def put_toplevel_on_center():               # Toplevel place on screen
    '''routine which set appropriate argument value for using one or 
       more displays and calling the center_toplevel routine'''
    monitors = get_monitors()
    # the a ability to automate the selection
    if len(monitors) == 1:   # only one monitor
        screen = 1
    else:
        screen = 2
    # top.geometry("1360x737+32+55") -- from gui file
    wid=1360
    hei=737
    if 1 <= screen <= len(monitors):
        screen = monitors[screen - 1]
        window_width = wid
        window_height = hei
        x = screen.x + (screen.width - window_width) // 2
        y = screen.y + (screen.height - window_height) // 2
        _top1.geometry(f"{window_width}x{window_height}+{x}+{y}")

def fade_in():                              # gradually Toplevel entrance
    '''routine to make the toplevel fadeing into the display'''
    # The fade in might not work under Windows
    if platform.system() == 'Windows':
        _top1.overridedirect(True)
    else:
        _top1.wm_attributes('-type', 'splash')
    for a in range(0, 100):
        b = a * .02
        _top1.wm_attributes('-alpha', b)
        _top1.update()
        sleep(.01)
    
def a_break(t):                             # the action in run time take a break
    '''routine which make the action in run time take a break'''
    var = tk.IntVar()
    root.after(t, var.set, 1)
    root.wait_variable(var)

def test_solved(num):                       # is images equal than solved
    if sh.player==0:
        if sh.player1_solved[str(num)]:
            return True
        else:
            return False
        # sh.player1_solved
    elif sh.player==1:
        if sh.player2_solved[str(num)]:
            return True
        else:
            return False    
    elif sh.player==2:
        if sh.player3_solved[str(num)]:
            return True
        else:
            return False
    elif sh.player==3:
        if sh.player4_solved[str(num)]:
            return True
        else:
            return False

def owl_teach():                            # display owl on the right side
    if sh.language==1:
        _w1.TLblExplanationBig.configure(foreground="#6B4322", text="ugla peikar på trong for spelarregistrering")
    else:
        _w1.TLblExplanationBig.configure(foreground="#6B4322", text="The owl points to the need for player registration")
       
def display_image(player_dict):             # put image on players canvas
    global _question
    num=0
    for key, value in player_dict.items():
        if test_solved(num):
            set_form_color(sh.player)
            sh.canvas_lst[num].create_image((100, 100), image=value, anchor='center')   # remember x,y is center of image
        else:
            sh.canvas_lst[num].create_image((100, 100), image=_question, anchor='center')   # remember x,y is center of image
        num+=1

def display_random():
    '''routine which display a random image on right canvas'''
    global _rnd_img
    temp_value=sh.big_im_dict[str(sh.big_im_random_dict[sh.round_num])][0]   # temp_value: /home/halvard/Skrivebord/minnespel smaabruk/assets/lotto_graphics/18.png <class 'str'>
    key_num = int(sh.big_im_random_dict[sh.round_num])+1        # sh.big_im_random_dict[sh.round_num]: 5 <class 'str'>
    sh.cbi_value=str(temp_value.split('/')[-1]).split('.')[0]   # sh.cbi_value: 1 <class 'str'>
    _rnd_img = sh.big_im_dict[sh.cbi_value][1]                  # get the image from dict 
    _w1.CanvasLotto.create_image((330, 330), image=_rnd_img, anchor='center')
    # set image text
    _w1.TLblExplanationBig.configure(foreground="#6B4322", text=sh.u_text[str(key_num+1)])

def read_text_file_lines(filename):         # an IO routine
    '''function which read text from file and return the
     file content in a string'''
    try:
        with open(filename, 'r') as f:
            f_text = f.read()
            signal = True   # Done.
            return signal, f_text
    except IOError:
        signal = False   # Something went wrong !!
        return signal, ''

def init_toml():                            # an IO routine
    config = { # a config dict
                     'using_config' : {'activated' : 0,},
                     'show_instruction' : {'startup' : 1,}}
    return config

def to_toml(config):                        # an IO routine
    # make a TOML file
    with open("config.toml", "wb") as f:
        tomli_w.dump(config, f)

def from_toml():                            # an IO routine
    # read a TOML file
    with open("config.toml", "rb") as f:
        config = tomli.load(f)
    sh.using_config = config['using_config']['activated']
    sh.show_instruction = config['show_instruction']['startup']

def get_language():
    # load translation .json file and make a dict per language
    translations = load_translations('./translations.json')   # json data
    # pattern matching to unpack a nested dictionary from a JSON file
    # get language data
    sh.language_no, sh.language_en = translations['no'], translations['en']
    set_language()
    
def load_translations(file_path):
    with open(file_path, 'r') as file:
        translations = json.load(file)
    return translations
 
def get_translation(translations, language, key):
    if language in translations and key in translations[language]:
        return translations[language][key]
    else:
        return f"Translation not found for language '{language}' and key '{key}'"
#   ========================================================
#
#     SPLASH SCREEN AND LANGUAGE ROUTINES
#   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
def menu_state(e, s):         # call back routine for aktivate the menubar
    '''gjør menyen tilgjengelig ved å endre status'''
    if s==1:
        _w1.menubar.entryconfig("H", state="normal")
    elif s==2:
        _w1.menubar.entryconfig("H", state="disabled")

def set_logo_text():
    '''routine which enter logo text according to selected language'''
    textbox=_w1.TextLogo
    textbox.configure(font=sh.myFont2)
    textbox.configure(wrap="word")
    textbox.delete(1.0, "end")   # clear text
    if sh.language==0: 
        sh.logo_txt="a Farm Memory game"
    else:
        sh.logo_txt="  Minnespel, småbruk"
    textbox.insert('end', sh.logo_txt)

def on_TBtnNext(*args):       # call back routine for using button Next
    if _debug:
        print('gameboardlotto_support.on_TBtnNext')
        for arg in args:
            print ('    another arg:', arg)
        sys.stdout.flush()
    _w1.TFrameSplash.destroy()
    _w1.TEntry1.focus()
    _w1.TEntry1.config(takefocus=1)
    _w1.TBtnNext.destroy()
    _w1.FrameLanguage.destroy()
    if sh.show_instruction:
        sh.show_instruction=0
    menubar_title_update()
    
def display_splash():
    '''routine which display the splash screen'''
    global _splash
    _w1.TFrameSplash.lift()
    _splash = tk.Image("photo", file='assets/lotto_graphics/splash_screen.png')
    _w1.CanvasSplash.create_image((660, 330), image=_splash, anchor='center')
    fade_in() 
    a_break(sh.spalsh_delay)
    if sh.show_instruction:
        global _instructions
        _instructions = tk.Image("photo", file='assets/lotto_graphics/instructions.png')
        _w1.CanvasSplash.create_image((660, 330), image=_instructions, anchor='center')
        on_mnu_help()
    else:
        sh.show_instruction=False
        _w1.FrameLanguage.place(x=546, y=689, height=40, width=235)
        _w1.FrameLanguage.lift()
    sh.splash_screen = 0

#   ========================================================
#
#     INSTRUCTION SECTION
#   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

def display_owl_right():
    '''routine which display a owl image on right canvas'''
    global _owl_right
    _owl_right= tk.Image("photo", file='assets/lotto_graphics/owl_right.png')
    _w1.CanvasLotto.create_image((330, 330), image=_owl_right, anchor='center')

#   ========================================================
#
#     REGISTRATION SECTION
#   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

def on_TBtnGoOn(*args):       # call back rutine to start the game
    if _debug:
        print('minnespel_smaabruk_support.on_TBtnGoOn')
        for arg in args:
            print ('    another arg:', arg)
        sys.stdout.flush()
    # read player 1    
    sh.player_name[1]=_w1.player1var.get()
    if not len(sh.player_name[1])==0:
        pass ##_w1.TBtnPlayer1.configure(text=sh.player_name[1])
    else:
        pass ##_w1.TBtnPlayer1.destroy()
    # read player 2
    sh.player_name[2]=_w1.player2var.get()
    if not len(sh.player_name[2])==0:
        pass ##_w1.TBtnPlayer2.configure(text=sh.player_name[2])
    else:
        pass ##_w1.TBtnPlayer2.destroy()
    # read player 3
    sh.player_name[3]=_w1.player3var.get()
    if not len(sh.player_name[3])==0:
        pass ## _w1.TBtnPlayer3.configure(text=sh.player_name[3])
    else:
        pass ## _w1.TBtnPlayer3.destroy()
    # read player 4
    sh.player_name[4]=_w1.player4var.get()
    if not len(sh.player_name[4])==0:
        pass ##_w1.TBtnPlayer4.configure(text=sh.player_name[4])
    else:
        pass ##_w1.TBtnPlayer4.destroy()
    
    
    # remove the lid over players button
    #_w1.TLblLid.destroy()
    # lift the canvas frame to top
    _w1.TFrame1.lift()
    # remove the owl image
    _w1.CanvasLotto.delete("all")
    # display first lotto card
    display_random()   # display a random image on CanvasLotto
    add_game_round()
    menubar_activated()
    menubar_player_update()
    _w1.TFrame5.place(x=10)
    _w1.TFrame2.place(x=685)

def on_TBtnPlayer1(*args):    # call back for virituell player button
    if _debug:
        print('minnespel_smaabruk_support.on_TBtnPlayer1')
        for arg in args:
            print ('    another arg:', arg)
        sys.stdout.flush()
    sh.player=0
    player_dict=sh.player_lst[sh.player]
    set_form_color(sh.player)
    display_image(player_dict)
    menubar_player_update()

def on_TBtnPlayer2(*args):    # call back for virituell player button
    if _debug:
        print('minnespel_smaabruk_support.on_TBtnPlayer2')
        for arg in args:
            print ('    another arg:', arg)
        sys.stdout.flush()
    sh.player=1
    player_dict=sh.player_lst[sh.player]
    set_form_color(sh.player)
    display_image(player_dict)
    menubar_player_update()
    
def on_TBtnPlayer3(*args):    # call back for virituell player button
    if _debug:
        print('minnespel_smaabruk_support.on_TBtnPlayer3')
        for arg in args:
            print ('    another arg:', arg)
        sys.stdout.flush()
    sh.player=2
    player_dict=sh.player_lst[sh.player]
    set_form_color(sh.player)
    display_image(player_dict)
    menubar_player_update()
    
def on_TBtnPlayer4(*args):    # call back for virituell player button
    if _debug:
        print('minnespel_smaabruk_support.on_TBtnPlayer4')
        for arg in args:
            print ('    another arg:', arg)
        sys.stdout.flush()
    sh.player=3
    player_dict=sh.player_lst[sh.player]
    set_form_color(sh.player)
    display_image(player_dict)
    menubar_player_update()

def menubar_activated():
    '''give menubar new label, font, length and color'''
    _w1.menubar.entryconfigure("                                                                              ",   label="space3")
    _w1.menubar.entryconfigure("space3",   label=" "*10, foreground="#8B8878", state="disabled")
    # set space menu items normal
    _w1.menubar.entryconfigure("           ", label="clock", 
                                              foreground="#8B8878", 
                                              font=sh.myFont3, 
                                              state="normal")
    _w1.menubar.entryconfigure("                     ", label="cur_user",
                                                        foreground="#8B8878",
                                                        font="-family {TlwgTypewriter} -size 20 -weight bold",
                                                        state="normal")   # current_user

    _w1.menubar.entryconfigure("                      ", label="title",
                                                         foreground="#8B8878",
                                                         font=sh.myFont1,
                                                         state="normal")
    _w1.menubar.entryconfigure("title", label=sh.logo_txt, 
                                        state="disabled")
                                        
    _w1.menubar.entryconfigure("clock", label=f"  {sh.current_time_1[0:5]}  ", 
                                        state="disabled")

def make_mystyle():
    # set TFrame style
    sh.style.map('TFrame',
                background=[('active', '#8B8878'),   # bg2),
                            ('disabled', 'gray76'),
                            ('readonly', 'firebrick2')],
                bordercolor=[('active', '#FFFAFA'),   # fg2),
                            ('disabled', 'gray24'),   # fg1),
                            ('readonly', 'gray50')]   # fg3)],
                )
    sh.style.map('TButton',
                background=[('active', '#8B8878'),
                            ('disabled', 'gray76'),
                            ('readonly', 'firebrick2')],
                foreground=[('active', '#FFFAFA'),
                            ('disabled', 'gray24'),
                            ('readonly', 'gray50')]
                )    

def set_form_color(player):
    # change background color to player color
    sh.style.configure('MyTFrame.TFrame',
                    background=sh.form_color_lst[sh.player],
                    bordercolor='gray24')
    _w1.TFrame1.configure(style='MyTFrame.TFrame')

def set_button_color():
    for inx, button in enumerate(sh.button_lst):
        sh.style.configure(sh.id_lst[inx],
                    background='#8B8878',
                    foreground=sh.form_color_lst[inx]
                        )
        button.configure(style=sh.id_lst[inx])

def validate_input1(*args):
    # start validating this entry
    validate_input(_w1.player1var)
    
def validate_input2(*args):
    # start validating this entry
    validate_input(_w1.player2var)

def validate_input3(*args):
    # start validating this entry
    validate_input(_w1.player3var)

def validate_input4(*args):
    # start validating this entry
    validate_input(_w1.player4var)

def validate_input(player_var):
    # Get the current value of the entry
    input_value = player_var.get()
    # Check if the input is a number
    if input_value.isdigit():
        pass
    else:
        if input_value.endswith(" "):   # space not allowed
            player_var.set('')
        elif input_value.isalpha():     # letter is allowed
            if input_value.istitle():   # first letter must be capitalized
                pass
            else:
                player_var.set('')
        else:
            player_var.set('')

def retur_entry1(*args):
    _w1.TEntry1.tk_focusNext().focus_set()
    _w1.TEntry1.config(takefocus=1)

def retur_entry2(*args):
    _w1.TEntry2.tk_focusNext().focus_set()
    _w1.TEntry2.config(takefocus=1)

def retur_entry3(*args):
    _w1.TEntry3.tk_focusNext().focus_set()
    _w1.TEntry3.config(takefocus=1)

def retur_entry4(*args):
    _w1.TBtnGoOn.focus_set()   # tk_focusNext().focus_set()
    _w1.TBtnGoOn.config(takefocus=1)

#   ========================================================
#
#     PREFERENCES SECTION
#   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

def on_Rbtn(*args):           # call back routine for using rbtn language
    '''samler alle språk relaterte oppgåver'''
    if _debug:
        print('gameboardlotto_support.on_Rbtn')
        for arg in args:
            print ('    another arg:', arg)
        sys.stdout.flush()
    result = _w1.selectedButton.get()
    print(result, type(result))
    sh.language=result
    if result:   # Norwegian
        print('Norsk språkføre er valgt')
    else:
        print('The English language setting is selected')
    owl_teach()
    set_language()

def on_tch_display(*args):    # call back routine for using tomli
    if _debug:
        print('minnespel_smaabruk_support.on_tch_display')
        for arg in args:
            print ('    another arg:', arg)
        sys.stdout.flush()
    which=_w1.tch47.get()
    # _w1.TCheckbuttonDisplay
    print(which)
    if which == 0:
        config = { # a config dict
                         'using_config' : {'activated' : 0,},
                         'show_instruction' : {'startup' : 0,}}
        to_toml(config)
    else:
        
        config = { # a config dict
                         'using_config' : {'activated' : 0,},
                         'show_instruction' : {'startup' : 1,}}
        to_toml(config)

def on_preferences(*args):    # call back routine for using mnu.button preferences
    if _debug:
        print('gameboardlotto_support.on_preferences')
        for arg in args:
            print ('    another arg:', arg)
        sys.stdout.flush()
    _w1.TCheckbuttonDisplay.place(x=545, y=232, width=241, height=23)
    _w1.TFramePreferences.place(x=240, y=140, height=600, width=915)
    _w1.TFramePreferences.lift()

def on_TButtonDismissPref(*args):
    if _debug:
        print('minnespel_smaabruk_support.on_TButtonDismissPref')
        for arg in args:
            print ('    another arg:', arg)
        sys.stdout.flush()
    _w1.TFramePreferences.place(x=2000)
    _w1.TFramePreferences.lower()

#   ========================================================
#
#     HELP SECTION
#   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

def on_mnu_help(*args):
    '''routine which display instructions into a scrolledtextbox 
       according to selected language'''
    if _debug:
        print('minnespel_smaabruk_support.on_mnu_help')
        for arg in args:
            print ('    another arg:', arg)
        sys.stdout.flush()
    # display instructions in _w1.ScrolledtextHelp
    _w1.TFrameInfo.place(x=240, y=137, height=600, width=915)
    _w1.TFrameInfo.lift()
    # display instruction info in _w1.ScrolledtextHelp

    textbox=_w1.ScrolledtextHelp   # displaying instructions
    textbox.place(x=65)
    _w1.ScrolledtextHelp.place(width=841)   # 906-65= 841  
    textbox.configure(font=sh.myFont0)
    textbox.configure(wrap="word")
    textbox.delete(1.0, "end")   # _w1.tch47clear text
    textbox.insert('end', sh.instruction_txt)

def on_TButtonDismiss(*args):
    if _debug:
        print('minnespel_smaabruk_support.on_TButtonDismiss')
        for arg in args:
            print ('    another arg:', arg)
        sys.stdout.flush()
    _w1.TFrameInfo.place(x=2000)
    _w1.TFrameInfo.lower()
    if sh.show_instruction:
        _w1.FrameLanguage.place(x=546, y=689, height=40, width=235)
        _w1.FrameLanguage.lift()

#   ========================================================
#
#     ABOUT SECTION
#   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

def on_mnu_about(*args):
    '''routine which display instructions into a scrolledtextbox 
       according to selected language'''
    if _debug:
        print('minnespel_smaabruk_support.on_mnu_about')
        for arg in args:
            print ('    another arg:', arg)
        sys.stdout.flush()
    # display aboutbox in _w1.ScrolledtextHelp
    _w1.TFrameInfo.place(x=240, y=137, height=600, width=915)
    _w1.TFrameInfo.lift()
    textbox=_w1.ScrolledtextHelp   # displaying instructions
    textbox.place(x=65)
    _w1.ScrolledtextHelp.place(width=841)   # 906-65= 841
    textbox.configure(font=sh.myFont0)
    textbox.configure(wrap="word")
    textbox.delete(1.0, "end")   # _w1.tch47clear text
    textbox.insert('end', sh.about_txt)
    
#   ========================================================
#
#     HALL OF FAME SECTION
#   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
#
#
#
#   ========================================================
#
#     PLAYING SECTION
#   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

def on_slide(*args):          # call back routine after using mouse on canvas
    if _debug:
        print('minnespel_smaabruk_support.on_slide')
        for arg in args:
            print ('    another arg:', arg)
        sys.stdout.flush()
    which=arg
    if which==1:
        sh.can=sh.can1
        slide(which)
    elif which==2:
        sh.can=sh.can2
        slide(which)
    elif which==3:
        sh.can=sh.can3
        slide(which)
    elif which==4:
        sh.can=sh.can4
        slide(which)
    elif which==5:
        sh.can=sh.can5
        slide(which)
    elif which==6:
        sh.can=sh.can6
        slide(which)
    elif which==7:
        sh.can=sh.can7
        slide(which)
    elif which==8:
        sh.can=sh.can8
        slide(which)
    elif which==9:
        sh.can=sh.can9
        slide(which)

def turn_card(*args):         # management of sliding images on cards
    if _debug:
        print('minnespel_smaabruk_support.turn_card')
        for arg in args:
            print ('    another arg:', arg)
        sys.stdout.flush()
    which= arg   # which canvas is visited
    on_slide(which)   # slide from back to image
    test_solved(which)

def get_players_image(which):
    im = eval(f'sh.player{sh.player+1}_im_np[str({which})]') 
    return im

def get_image_num(im):
    num = str(im.split('/')[-1]).split('.')[0]
    return num

def set_image_back():
    sh.im_back = os.path.join(sh.path_photo,"owl_book.png")

def slide(which):
    '''do get a image on players canvas to turn over'''
    if sh.player > 3:   # do not let the playes number be larger than 4
        sh.player = 0
    sh.im_carrier = get_players_image(which)          # get players image
    sh.cti_value = get_image_num(sh.im_carrier)       # get number from image
    small_image_subtitle()
    
    temp_gif = "/test.gif"                            # set name on temporary gif file
    sh.imList=[sh.im_carrier, sh.im_back, temp_gif]   # make argument for process_images rutine
    process_images(f"{sh.imList[1]}", f"{sh.imList[0]}", f"{sh.path_photo}{sh.imList[2]}")   # --> -4-
    displayfile(f"{sh.path_photo}{sh.imList[2]}")
    # hide cursor/ pionter when sliding images to prevent using the mouse during img showing
    root.config(cursor="none")
    is_solved(which)

def is_solved(which):                       # is the image found
    '''compare thumbnail img and random big img if equal than set flag'''
    # extract the image number from path
    player_number=str(int(sh.player)+1)
    ##print('player_number:', player_number, type(player_number))
    current_tumbnail_image = eval(f'sh.player{sh.player+1}_im_np[str({which})]')
    ##print('current_tumbnail_image:', current_tumbnail_image, type(current_tumbnail_image))
    sh.cti_value=str(current_tumbnail_image.split('/')[-1:])[2:-6]
    print('sh.cti_value:', sh.cti_value, type(sh.cti_value))
    # sh.cbi_value ?
    print('sh.cbi_value:', sh.cbi_value, type(sh.cbi_value))
    
    if sh.cti_value == sh.cbi_value:   # EQUAL IMAGES!!!
        print('Yea, equal!!!')
        solved_dict_name=eval(f'sh.player{player_number}_solved')
        the_key=str(which)
        solved_dict_name[the_key]=1
        display_random()
        # show cursor/ pionter when sliding images is finish
        root.config(cursor="arrow")
        
    else:
        slide_back(which)  # turn image back
        # change big image
        if sh.player==5:
            sh.player=0
        sh.player+=1    
        set_form_color(sh.player)
        change_player=f'on_TBtnPlayer{sh.player}()'
        print('change_player:', change_player, type(change_player))
        #      change_player: on_TBtnPlayer1() <class 'str'>

        exec(change_player)

        pl_btn=f'on_TBtnPlayer{player_number}()'
        
        eval(pl_btn)
        player_dict=sh.player_lst[sh.players_turn]
        display_image(player_dict) # player 1 at init time
        # show cursor/ pionter when sliding images is finish
        root.config(cursor="arrow")

def small_image_back_subtitle():
    _w1.TLblExplanationLittle.configure(foreground=str(sh.form_color_lst[sh.player+1]), text=sh.guidance_txt)

def small_image_subtitle():
    if sh.language==1:
        _w1.TLblExplanationLittle.configure(foreground=str(sh.form_color_lst[sh.player+1]), text="")   # sh.u_text_no[str(sh.cti_value)])
    else:
        _w1.TLblExplanationLittle.configure(foreground=str(sh.form_color_lst[sh.player+1]), text="")   # sh.u_text_en[str(sh.cti_value)])

def slide_back(which):                                                                                         # which = ein av ni canvas   td.1
    '''image on players canvas to turn'''
    a_break(sh.memo_delay)
    small_image_back_subtitle()

    temp_gif = "/test2.gif"                            # set name on temporary gif file
    sh.imList=[sh.im_carrier, sh.im_back, temp_gif]   # make argument for process_images rutine
    process_images(f"{sh.imList[1]}", f"{sh.imList[0]}", f"{sh.path_photo}{sh.imList[2]}")
    displayfile(f"{sh.path_photo}{sh.imList[2]}")

def process_images(image1_path, image2_path, output_gif_path, num_frames=10):
    # Open the images
    thumbnail_size=(200,200)
    im1=Image.open(image1_path)
    im1=purePilAlpha2colorV2(im1, color=(255, 255, 255))
    im2=Image.open(image2_path)
    im2=purePilAlpha2colorV2(im2, color=(255, 255, 255))
    im1.thumbnail(thumbnail_size)
    im2.thumbnail(thumbnail_size)
    image1 = np.array(im1)
    image2 = np.array(im2)
    # Ensure both images have the same size
    assert image1.shape == image2.shape, "Images must have the same dimensions."
    # Create a GIF file
    gif_frames = []
    # Generate frames by sliding image2 over image1
    for offset in np.linspace(0, image1.shape[1], num_frames, dtype=int):
        processed_matrix = slide_images(image1, image2, offset)
        # Create an image from the processed data
        gif_frames.append((processed_matrix).astype(np.uint8))
    # Save the frames as a GIF using imageio
    if sh.direction == 0:
        with imageio.get_writer(output_gif_path, mode='I', duration=0.1) as writer:
            #for frame in np.flip(gif_frames):   # turn images up side down
            for frame in gif_frames:   # [::-1] reversed slide
                 writer.append_data(frame)
        sh.direction = 1
    elif sh.direction == 1:
        with imageio.get_writer(output_gif_path, mode='I', duration=0.1) as writer:
            #for frame in np.flip(gif_frames):   # turn images up side down
            for frame in gif_frames[::-1]:   # [::-1] reversed slide
                 writer.append_data(frame)
        sh.direction = 0

def purePilAlpha2colorV2(image, color=(255, 255, 255)):
    '''convert RGBA image mode to RGB'''
    """Alpha composite an RGBA Image with a specified color.
    Source: http://stackoverflow.com/a/9459208/284318
    Keyword Arguments:
    image -- PIL RGBA Image object
    color -- Tuple r, g, b (default 255, 255, 255)
    """
    #print('image.mode:', image.mode, type(image.mode))
    if image.mode=="RGB":   # did not need converting
        return image
    image.load()  # needed for split()
    background = PIL.Image.new("RGB", image.size, '#d9d9d9')
    background.paste(image, mask=image.split()[3])  # 3 is the alpha channel
    return background

def slide_images(image1, image2, offset):
    # Slide image2 over image1 by the specified offset
    width, height, channels = image1.shape
    result = np.zeros_like(image1)
    if offset >= 0:
        result[:, :width-offset] = image1[:, offset:]
        result[:, width-offset:] = image2[:, :offset]
    else:
        result[:, -offset:] = image1[:, :offset]
        result[:, :-offset] = image2[:, -offset:]
    return result

def displayfile(filename):
    global _top1, _w1, frames, _image
    file = Image.open(filename)
    frameCnt = number_of_frames(file)
    frames = [tk.PhotoImage( file=filename, format = f'gif -index {i}')
                for i in range(frameCnt)]
    update(0)

# sh.direction = 0

def number_of_frames(gif):
    "Prints and returns the number of frames of the gif"
    return gif.n_frames

def update(ind):
    global _top1, frames
    try:
        frame = frames[ind]
        ind += 1
        sh.can.create_image((100, 100), image=frame, anchor='center')
        root.after(45, update, ind)   # duration of image shift
    except:
        pass

def add_game_round():                       # legg til spelerunde
    global _im
    
    # is the selected game board image the same as the large image on the right?
    #   yes;
    #       if there are more pictures, return to the start of this routine
    #       else: quit
    #   no;
    #       next player, and change color

    
    #is_solved()   # check if two images is equal
    
    if sh.round_num < 37:
        sh.round_num += 1

    #display_random()   # temporarily until sh.equal is in place

    if sh.new_round:
        # change big image
        sh.players_turn += 1
        if sh.players_turn==5:
            sh.players_turn = 1

        
        set_form_color(sh.players_turn)
        player_dict = sh.player_lst[sh.players_turn]
        display_image(player_dict) # player 1 at init time


#   ========================================================
#
#     CLEANUP SECTION
#   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

def on_TBtnExit(*args):                     # call back routine to end the game
    if _debug:
        print('minnespel_smaabruk_support.on_TBtnExit')
        for arg in args:
            print ('    another arg:', arg)
        sys.stdout.flush()
    cleanUp()
    sys.exit()

def remove_tmp_file():
    '''removes share.py file created by the program while running'''
    def remove_file(filename):
        try:
            import os
            os.remove(filename)   # remove files
            print(f'   Temperary file {filename} is removed ')
        except:
            print(f'   Can not remove file: {filename}, sorry!')
    filename = f"{module_name}.py"
    remove_file(filename)
    filename = "./assets/lotto_graphics/test.gif"
    remove_file(filename)

def cleanUp():
    '''Calculates the Time Spent and Notifies that the App is Finished.
       Can Optionally Remove Tempered Files.'''
    # import datetime
    print('='*sh.decoration, '\n')
    print('Roundup...')
    if not sh.language:
        _show('Ends', 'Sorry!\nNow the game is over.')
    else:
        _show('Avskjedmelding', 'Programmet er no avslutta!')
    # give finish time
    current_time = datetime.datetime.now()
    current_time_2 = f'{current_time.hour:02}:{current_time.minute:02}:{current_time.second}'
    h1,m1,s1 = sh.current_time_1.split(':')
    h2,m2,s2 = current_time_2.split(':')
    tot_h=int(h2)-int(h1)
    tot_m=int(m2)-int(m1)
    tot_s=int(s2)-int(s1)
    if tot_s < 0:
        tot_m-=1
        tot_s=60+tot_s
    if tot_m < 0:
        tot_h-=1
        tot_m=60+tot_m
    tot_time=f'{tot_h:02}:{tot_m:02}:{tot_s:02}'
    print(f'   finish time : {current_time_2}')
    print('   time used   :', tot_time )
    remove_tmp_file()
    
    print('Done.')

#   ========================================================
#
#     call main application
#   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

if __name__ == '__main__':
    minnespel_smaabruk.start_up()
